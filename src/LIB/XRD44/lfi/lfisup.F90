! Oct-2012 P. Marguinaud 64b LFI
! Jan-2011 P. Marguinaud Thread-safe LFI

SUBROUTINE LFISUP_FORT                                     &
&                     (LFI, KREP, KNUMER, CDNOMA, KLONUT )
USE LFIMOD, ONLY : LFICOM
USE PARKIND1, ONLY : JPRB
USE YOMHOOK , ONLY : LHOOK, DR_HOOK
USE LFI_PRECISION
IMPLICIT NONE
!****
!        SOUS-PROGRAMME PERMETTANT DE *SUPPRIMER* UN ARTICLE LOGIQUE
!     (DE DONNEES) SUR UNE UNITE LOGIQUE OUVERTE POUR LE LOGICIEL
!     DE FICHIERS INDEXES *LFI*; L'ARTICLE EST TRANSFORME EN "TROU"
!     DANS L'INDEX.
!**
!    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DU SOUS-PROGRAMME;
!                KNUMER (ENTREE) ==> LFI%NUMERO DE L'UNITE LOGIQUE;
!                CDNOMA (ENTREE) ==> NOM DE L'ARTICLE A RECHERCHER;
!                KLONUT (SORTIE) ==> LONGUEUR *REUTILISABLE*
!                                    DE L'ARTICLE SUPPRIME.
!
!
TYPE(LFICOM) :: LFI
CHARACTER CDNOMA*(*), CLNOMA*(LFI%JPNCPN)
!
INTEGER (KIND=JPLIKB) KREP, KNUMER, KLONUT, IMDESC 
INTEGER (KIND=JPLIKB) IRANG, IREP, ILCDNO, ILCLNO
INTEGER (KIND=JPLIKB) IDECBL, IPOSBL, IARTEX, INBALO 
INTEGER (KIND=JPLIKB) IRGPIM, IRGPIF, ILONGA, J
INTEGER (KIND=JPLIKB) IPOSEX, IFACTM, ILARPH, INALPP 
INTEGER (KIND=JPLIKB) INALPI, INTPPI, INBPIR
INTEGER (KIND=JPLIKB) INPPIM, IRECPI, IREC, IRGPI 
INTEGER (KIND=JPLIKB) IRPIMS, INPILE, IRNGMS
INTEGER (KIND=JPLIKB) IRETIN, INIMES
!
LOGICAL LLVERF
!
CHARACTER(LEN=LFI%JPLSPX) CLNSPR
CHARACTER(LEN=LFI%JPLMES) CLMESS
CHARACTER(LEN=LFI%JPLFTX) CLACTI
LOGICAL LLFATA

!**
!     1.  -  CONTROLES DES PARAMETRES D'APPEL, PUIS INITIALISATIONS.
!-----------------------------------------------------------------------
!
!        Appel legerement anticipe a LFINUM, garantissant l'initialisa-
!     tion des variables globales du logiciel a la 1ere utilisation.
!
REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('LFISUP_FORT',0,ZHOOK_HANDLE)
CLACTI=''
CALL LFINUM_FORT                    &
&               (LFI, KNUMER,IRANG)
LLVERF=.FALSE.
IREP=0
KLONUT=0
ILCDNO=INT (LEN (CDNOMA), JPLIKB)
!
IF (ILCDNO.LE.0) THEN
  IREP=-15
  CLNOMA=LFI%CHINCO(:LFI%JPNCPN)
  ILCLNO=LFI%JPNCPN
  GOTO 1001
ELSEIF (CDNOMA.EQ.' ') THEN
  IREP=-18
  CLNOMA=' '
  ILCLNO=1
  GOTO 1001
ENDIF
!
!        Recherche de la longueur "utile" du nom d'article specifie.
!        (c'est-a-dire sans tenir compte des blancs terminaux eventuels)
!
IDECBL=0
!
101 CONTINUE
IPOSBL=IDECBL+INT (INDEX (CDNOMA(IDECBL+1:),' '), JPLIKB)
!
IF (IPOSBL.LE.IDECBL) THEN
  ILCLNO=ILCDNO
ELSEIF (CDNOMA(IPOSBL:).EQ.' ') THEN
  ILCLNO=IPOSBL-1
ELSE
  IDECBL=IPOSBL
  GOTO 101
ENDIF
!
IF (ILCLNO.LE.LFI%JPNCPN) THEN
  CLNOMA=CDNOMA(:ILCLNO)
ELSE
  CLNOMA=CDNOMA(:LFI%JPNCPN)
  ILCLNO=LFI%JPNCPN
  IREP=-15
  GOTO 1001
ENDIF
!
IF (IRANG.EQ.0) THEN
  IREP=-1
  GOTO 1001
ENDIF
!
 IF (LFI%LMULTI) CALL LFIVER_FORT                              &
&                                (LFI, LFI%VERRUE(IRANG),'ON')
LLVERF=LFI%LMULTI
!
IF (LFI%NEXPOR(IRANG).GT.0) THEN
!
!         Fichier en cours d'export... la seule modification acceptee
!         est l'ajout de nouveaux articles.
!
  IREP=-37
  GOTO 1001
ENDIF
!
IARTEX=0
INBALO=LFI%MDES1D(IXM(LFI%JPNALO,IRANG))
!
IF (INBALO.NE.0) THEN
!**
!     2.  -  EXPLORATION DES (PAIRES DE) PAGES ET ARTICLES D'INDEX,
!            A LA RECHERCHE DE L'ARTICLE LOGIQUE A SUPPRIMER.
!-----------------------------------------------------------------------
!
  CALL LFIRAN_FORT                                  &
&                 (LFI, IREP,IRANG,CLNOMA(:ILCLNO), &
&                  IRGPIM,IARTEX,IRETIN)
!
  IF (IRETIN.EQ.1) THEN
    GOTO 903
  ELSEIF (IRETIN.EQ.2) THEN
    GOTO 904
  ELSEIF (IRETIN.NE.0) THEN
    GOTO 1001
  ENDIF
!
ENDIF
!
IF (IARTEX.EQ.0) THEN
  IREP=-20
  CLACTI=CLNOMA(:ILCLNO)
  GOTO 1001
ENDIF
!
!        ON COMPLETE LES CARACTERISTIQUES DE L'ARTICLE PAR SA LONGUEUR,
!     EXPRIMEE EN TERME DE DONNEES "LISIBLES" POUR L'UTILISATEUR.
!
IRGPIF=LFI%MRGPIF(IRGPIM)
!
IF (.NOT.LFI%LPHASP(IRGPIM)) THEN
!
  CALL LFIPHA_FORT                                &
&                 (LFI, IREP,IRANG,IRGPIM,IRETIN)
!
  IF (IRETIN.EQ.1) THEN
    GOTO 903
  ELSEIF (IRETIN.EQ.2) THEN
    GOTO 904
  ELSEIF (IRETIN.NE.0) THEN
    GOTO 1001
  ENDIF
!
ENDIF
!
ILONGA=LFI%MLGPOS(IXM(2*IARTEX-1,IRGPIM))
IPOSEX=LFI%MLGPOS(IXM(2*IARTEX,IRGPIM))
IFACTM=LFI%MFACTM(IRANG)
ILARPH=LFI%JPLARD*IFACTM
INALPP=LFI%JPNAPP*IFACTM
INALPI=MIN (INALPP,INBALO-(IRGPIF-1)*INALPP)
INTPPI=(INBALO-1+INALPP)/INALPP
INBPIR=LFI%MDES1D(IXM(LFI%JPNPIR,IRANG))
INPPIM=LFI%NPPIMM(IRANG)
!**
!     3.  -  AFIN D'ASSURER UN MEILLEUR RECYCLAGE (EVENTUEL) DE CE FUTUR
!            TROU, ON CALCULE SA LONGUEUR EFFECTIVEMENT REUTILISABLE.
!-----------------------------------------------------------------------
!
IF (IARTEX.EQ.1.AND.IRGPIF.GT.INBPIR) THEN
!
!            IL Y A EU DEBORDEMENT DES P.A.I. PREALLOUEES, ET IL Y A
!        EN OUTRE UNE P.A.I. SUR LE FICHIER, JUSTE DERRIERE L'ARTICLE
!        LOGIQUE AUQUEL ON S'INTERESSE.
!
  IRECPI=LFI%MDES1D(IXM(ILARPH+1-(IRGPIF-INBPIR),IRANG))
  KLONUT=ILARPH*(IRECPI-1)-IPOSEX+1
ELSEIF (IARTEX.EQ.INALPI.AND.IRGPIF.EQ.INTPPI) THEN
!
!           CAS OU L'ARTICLE TROUVE EST LE DERNIER ARTICLE LOGIQUE DE
!        DONNEES, SANS P.A.I. JUSTE DERRIERE.
!           LA DERNIERE POSITION REUTILISABLE SANS AUGMENTER LA TAILLE
!       DU FICHIER CORRESPOND A LA FIN DU DERNIER ARTICLE PHYSIQUE
!       CONTENANT DES DONNEES, OU A LA FIN DU DERNIER ARTICLE PHYSIQUE
!       EFFECTIVEMENT ECRIT SUR LE FICHIER.
!
  IMDESC=LFI%MDES1D(IXM(LFI%JPNAPH,IRANG))
  IREC=MAX (1+(IPOSEX+ILONGA-2)/ILARPH,IMDESC)
  KLONUT=ILARPH*IREC-IPOSEX+1
!
!          EN ARRIVANT AU TEST CI-DESSOUS, ON EST DONC SUR QUE L'ARTICLE
!        TROUVE N'EST PAS LE DERNIER ARTICLE LOGIQUE.
!          ON VA CALCULER LA DISTANCE ENTRE LES DEBUTS D'ARTICLE,
!        CE QUI CONSTITUE LA LONGUEUR REUTILISABLE CHERCHEE.
!
ELSEIF (IARTEX.NE.INALPP) THEN
!
!           L'ARTICLE SUIVANT EST DANS LA MEME PAGE D'INDEX...
!
  KLONUT=LFI%MLGPOS(IXM(2*IARTEX+2,IRGPIM))-IPOSEX
ELSE
!
!           L'ARTICLE TROUVE EST EN PLUS EN FIN DE PAGE D'INDEX...
!       RECHERCHE DANS LES P.P.I. DE LA P.A.I. SUIVANTE.
!
  DO J=2,INPPIM
  IRGPI=LFI%MRGPIM(J,IRANG)
!
  IF (LFI%MRGPIF(IRGPI).EQ.(IRGPIF+1)) THEN
!
    IRPIMS=IRGPI
!
    IF (.NOT.LFI%LPHASP(IRPIMS)) THEN
!
      CALL LFIPHA_FORT                                &
&                     (LFI, IREP,IRANG,IRPIMS,IRETIN)
!
      IF (IRETIN.EQ.1) THEN
        GOTO 903
      ELSEIF (IRETIN.EQ.2) THEN
        GOTO 904
      ELSEIF (IRETIN.NE.0) THEN
        GOTO 1001
      ENDIF
!
    ENDIF
!
    GOTO 305
!
  ENDIF
!
  ENDDO
!
!             LA P.A.I. SUIVANTE (EN RANG DANS LE FICHIER) N'EST PAS
!          EN MEMOIRE; DECIDEMENT, CELA SE GATE ! ... ON L'Y MET.
!
  INPILE=2
  CALL LFIPIM_FORT                                 &
&                 (LFI, KREP,IRANG,IRNGMS,IRPIMS,  &
&                  IRGPIF+1,IRGPIF,INPILE, IRETIN)
!
  IF (IRETIN.EQ.1) THEN
    GOTO 903
  ELSEIF (IRETIN.EQ.2) THEN
    GOTO 904
  ELSEIF (IRETIN.NE.0) THEN
    GOTO 1001
  ENDIF
!
305 CONTINUE
!
  KLONUT=LFI%MLGPOS(IXM(2_JPLIKB ,IRPIMS))-IPOSEX
ENDIF
!**
!     4  -  TRANSFORMATION EFFECTIVE DE L'ARTICLE LOGIQUE DE DONNEES
!           EN "TROU" D'INDEX.
!-----------------------------------------------------------------------
!
LFI%CNOMAR(IXC(IARTEX,IRGPIM))=' '
IF (LFI%NDERGF(IRANG).NE.LFI%JPNIL.AND.   &
&    LFI%CNDERA(IRANG).EQ.CLNOMA(:ILCLNO)) &
&    LFI%CNDERA(IRANG)=' '
LFI%LECRPI(IRGPIM,1)=.TRUE.
LFI%NBSUPP(IRANG)=LFI%NBSUPP(IRANG)+1
LFI%LMIMAL(IRANG)=LFI%LMIMAL(IRANG).OR.                       &
&                  ILONGA.EQ.LFI%MDES1D(IXM(LFI%JPLNAL,IRANG)) &
&              .OR.ILONGA.EQ.LFI%MDES1D(IXM(LFI%JPLXAL,IRANG))
LFI%NBTROU(IRANG)=LFI%NBTROU(IRANG)+1
LFI%MDES1D(IXM(LFI%JPLTAL,IRANG))=                         &
&                  LFI%MDES1D(IXM(LFI%JPLTAL,IRANG))-ILONGA
!
IF (KLONUT.NE.ILONGA) THEN
  LFI%MLGPOS(IXM(2*IARTEX-1,IRGPIM))=KLONUT
  LFI%LECRPI(IRGPIM,2)=.TRUE.
ENDIF
!
IF (.NOT.LFI%LMODIF(IRANG)) THEN
!
!         CAS DE LA PREMIERE MODIFICATION DEPUIS L'OUVERTURE DU FICHIER.
!
  LFI%LMODIF(IRANG)=.TRUE.
  CALL LFIMOE_FORT                         &
&                 (LFI, IREP,IRANG,IRETIN)
!
  IF (IRETIN.EQ.1) THEN
    GOTO 903
  ELSEIF (IRETIN.EQ.2) THEN
    GOTO 904
  ELSEIF (IRETIN.NE.0) THEN
    GOTO 1001
  ENDIF
!
ENDIF
!
GOTO 1001
!**
!     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
!-----------------------------------------------------------------------
!
903 CONTINUE
CLACTI='WRITE'
GOTO 909
!
904 CONTINUE
CLACTI='READ'
!
909 CONTINUE
!
!      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
!
IREP=ABS (IREP)
!**
!    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
!            VIA LE SOUS-PROGRAMME "LFIEMS" .
!-----------------------------------------------------------------------
!
1001 CONTINUE
KREP=IREP
LLFATA=LLMOER (IREP,IRANG)
!
IF (IRANG.NE.0) THEN
  LFI%NDEROP(IRANG)=15
  LFI%NDERCO(IRANG)=IREP
   IF (LLVERF) CALL LFIVER_FORT                               &
&                              (LFI, LFI%VERRUE(IRANG),'OFF')
ENDIF
!
IF (LLFATA.OR.IXNIMS (IRANG).EQ.2) THEN
  INIMES=2
ELSE
  IF (LHOOK) CALL DR_HOOK('LFISUP_FORT',1,ZHOOK_HANDLE)
  RETURN
ENDIF
!
CLNSPR='LFISUP'
WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KNUMER='',I3, &
&       '', CDNOMA='''''',A,'''''', KLONUT='',I8)')      &
&     KREP,KNUMER,CLNOMA(:ILCLNO),KLONUT
CALL LFIEMS_FORT                                 &
&               (LFI, KNUMER,INIMES,IREP,LLFATA, &
&                CLMESS,CLNSPR,CLACTI)
!
IF (LHOOK) CALL DR_HOOK('LFISUP_FORT',1,ZHOOK_HANDLE)

CONTAINS

#include "lficom2.ixc.h"
#include "lficom2.ixm.h"
#include "lficom2.ixnims.h"
#include "lficom2.llmoer.h"

END SUBROUTINE LFISUP_FORT



! Oct-2012 P. Marguinaud 64b LFI
SUBROUTINE LFISUP64                      &
&           (KREP, KNUMER, CDNOMA, KLONUT)
USE LFIMOD, ONLY : LFI => LFICOM_DEFAULT, &
&                   LFICOM_DEFAULT_INIT,   &
&                   NEW_LFI_DEFAULT
USE LFI_PRECISION
IMPLICIT NONE
! Arguments
INTEGER (KIND=JPLIKB)  KREP                                   !   OUT
INTEGER (KIND=JPLIKB)  KNUMER                                 ! IN   
CHARACTER (LEN=*)      CDNOMA                                 ! IN   
INTEGER (KIND=JPLIKB)  KLONUT                                 !   OUT

IF (.NOT. LFICOM_DEFAULT_INIT) CALL NEW_LFI_DEFAULT ()

CALL LFISUP_FORT                               &
&           (LFI, KREP, KNUMER, CDNOMA, KLONUT)

END SUBROUTINE LFISUP64

SUBROUTINE LFISUP                        &
&           (KREP, KNUMER, CDNOMA, KLONUT)
USE LFIMOD, ONLY : LFI => LFICOM_DEFAULT, &
&                   LFICOM_DEFAULT_INIT,   &
&                   NEW_LFI_DEFAULT
USE LFI_PRECISION
IMPLICIT NONE
! Arguments
INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
INTEGER (KIND=JPLIKM)  KNUMER                                 ! IN   
CHARACTER (LEN=*)      CDNOMA                                 ! IN   
INTEGER (KIND=JPLIKM)  KLONUT                                 !   OUT

IF (.NOT. LFICOM_DEFAULT_INIT) CALL NEW_LFI_DEFAULT ()

CALL LFISUP_MT                                &
&           (LFI, KREP, KNUMER, CDNOMA, KLONUT)

END SUBROUTINE LFISUP

SUBROUTINE LFISUP_MT                          &
&           (LFI, KREP, KNUMER, CDNOMA, KLONUT)
USE LFIMOD, ONLY : LFICOM
USE LFI_PRECISION
IMPLICIT NONE
! Arguments
TYPE (LFICOM)          LFI                                    ! INOUT
INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
INTEGER (KIND=JPLIKM)  KNUMER                                 ! IN   
CHARACTER (LEN=*)      CDNOMA                                 ! IN   
INTEGER (KIND=JPLIKM)  KLONUT                                 !   OUT
! Local integers
INTEGER (KIND=JPLIKB)  IREP                                   !   OUT
INTEGER (KIND=JPLIKB)  INUMER                                 ! IN   
INTEGER (KIND=JPLIKB)  ILONUT                                 !   OUT
! Convert arguments

INUMER     = INT (    KNUMER, JPLIKB)

CALL LFISUP_FORT                               &
&           (LFI, IREP, INUMER, CDNOMA, ILONUT)

KREP       = INT (      IREP, JPLIKM)
KLONUT     = INT (    ILONUT, JPLIKM)

END SUBROUTINE LFISUP_MT

!INTF KREP            OUT 
!INTF KNUMER        IN    
!INTF CDNOMA        IN    
!INTF KLONUT          OUT 
