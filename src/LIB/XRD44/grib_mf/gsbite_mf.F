      SUBROUTINE GSBITE_MF(KS,KD,KSKST,KSIZE,KSKBTW,K,KBPW,KMASK,YADIR)
      USE PARKIND1, ONLY : JPRB
      USE YOMHOOK , ONLY : LHOOK, DR_HOOK
      USE LFI_PRECISION

!
!     GSBITE: VECTORISING EXTRACTION/INSERTION OF BITS FROM/TO BITSTREAM
!
! INPUT:
!     KS:     IF YADIR='D', INPUT BIT STREAM, ELSE OUTPUT BIT STREAM
!     KD:     IF YADIR='D', OUTPUT WORDS, ELSE INPUT WORDS
!     KSKST:  NUMBER OF BITS SKIPPED AT BEGINNING OF KS
!     KSIZE:  NUMBER OF BITS TO BE EXTRACTED TO ONE WORD OF KD
!     KSKBTW: NUMBER OF BITS SKIPPED BETWEEN TWO WORDS TO BE EXTRACTED
!     K:      NUMBER OF WORDS TO BE EXTRACTED INTO KD (IF .LE.0, ONLY
!             CALCULATE KBPW AND KMASK
!     KBPW:   NUMBER OF BITS PER WORD IN KS, CALCULATED IF 0
!     KMASK:  MASKS FOR BIT PATTERNS, CALCULATED IF KMASK(2).EQ.0
!     YADIR:  DIRECTION OF CONVERSION: 'D' FOR DECODING, I.E.
!             EXTRACT WORDS KD(1...K)  FROM BITS KS(KSKST+1....)
!             IF NOT 'D', ENCODE, I.E. PACK WORDS KD(1....K) INTO BITS
!             KS(KSKST+1.....KSKST+K*(KSIZE+KSKBTW))
!
! OUTPUT:
!     KS,KD:  SEE ABOVE
!     KSKST:  UPDATED TO NR OF BITS USED, I.E. TO KSKST+K*(KSIZE+KSKBTW)
!     KBPW:   (IF 0 ON INPUT): NUMBER OF BITS IN EACH WORD OF KS
!     KMASK:  (IF (KMASK(2) WAS 0 ON INPUT): BIT PATTERN MASKS
!
!                                                     G.J.CATS 08 DEC 87
!
      IMPLICIT NONE
      INTEGER (KIND=JPLIKB) :: KS(*)
      INTEGER (KIND=JPLIKB) :: KD(*)
      INTEGER (KIND=JPLIKB) :: KMASK(*)
      INTEGER (KIND=JPLIKB) :: IS , ISHFT, ISH, IMASK
      INTEGER (KIND=JPLIKM) :: KSKST
      INTEGER (KIND=JPLIKM) :: KSIZE
      INTEGER (KIND=JPLIKM) :: KSKBTW
      INTEGER (KIND=JPLIKM) :: K
      INTEGER (KIND=JPLIKM) :: KBPW
      INTEGER (KIND=JPLIKM) :: IBDL
      INTEGER (KIND=JPLIKM) :: IBS,IENBS,IEND,ILCF,ILL,IOD,IOS
      INTEGER (KIND=JPLIKM) :: ISHF,ISKB,ISKW,ISKWS,ISTA,ISTD,ISTEP,ISTS
      INTEGER (KIND=JPLIKM) :: J,JBD,JI
      CHARACTER (LEN=1) :: YADIR
!
!     STATEMENT FUNCTIONS TO MANIPULATE BITS IN WORDS OF 64 BITS
!
!     DATA ONES/7777777777777777B/
!     DATA OOOS/0B/
!
!     1.  SINGLE BIT MANIPULATIONS
!
!     1.1 SET BIT KBIT IN WORD PW
!
!CRAY  IBSET(KW,KBIT)=OR(KW,SHIFT(1B,KBIT))
!
!     2.  WORD MANIPULATIONS, BIT BY BIT
!
!     2.1 ARE WORDS PW1 AND PW2 EQUAL?
!
!      LOGICAL NLEQAL
!     NLEQAL(PW1,PW2)=(PW1.XOR.PW2).EQ.0B
!
!     2.2 BITWISE AND AND OR
!
!CRAY  IAND(K1,K2)=AND(K1,K2)
!CRAY  IOR (K1,K2)= OR(K1,K2)
!
!     2.3 BITWISE NEGATION
!
!CRAY  NOT(K)=COMPL(K)
!
!     2.4 SHIFT (LEFT FOR KSH POSITIVE, RIGHT FOR KSH NEGATIVE)
!
!CRAY  ISHFT(K,KSH)=CVMGP(SHIFTL(K,KSH),SHIFTR(K,-KSH),KSH)
!
!     3.  SPECIAL PURPOSE
!
!     3.1 TAKE 4 LAST BITS OF KW, PUT THEM IN PW AT POS K*4-1
!
!     SETLEV(PW,KW,K)=OR(AND(PW,SHIFT(0B.EQV.17B,K*4-4)),
!    +SHIFT(AND(17B,KW),K*4-4))
!
!     3.2 EXTRACT FIELD [K*4-1:4] FROM PW
!
!     MGTLEV(PW,K)=AND(17B,SHIFT(PW,68-K*4))
!
!     1.  COMPLETE KBPW AND KMASK, RETURN IF 0 WORDS ARE TO BE EXTRACTED
!
      REAL(KIND=JPRB) :: ZHOOK_HANDLE
      IF (LHOOK) CALL DR_HOOK('GSBITE_MF',0,ZHOOK_HANDLE)
      IF(KBPW.EQ.0)THEN
         IS=KS(1)
         KS(1)=1
 1101    CONTINUE
         IF(KS(1).NE.0)THEN
            KBPW=KBPW+1
            KS(1)=ISHFT(KS(1),1)
            GOTO 1101
         ENDIF
         KS(1)=IS
      ENDIF
      IF(KMASK(2).EQ.0)THEN
         KMASK(KBPW+1)=0
         DO 1110 J=KBPW,1,-1
         KMASK(J)=IBSET(KMASK(J+1),KBPW-J)
 1110    CONTINUE
      ENDIF
      IF(K.LE.0) THEN
        IF (LHOOK) CALL DR_HOOK('GSBITE_MF',1,ZHOOK_HANDLE)
        RETURN
      ENDIF
!
!     2.  PRESET KD TO 0 IF KD IS OUTPUT I.E. WHEN DECODING
!
      IF(YADIR.EQ.'D')THEN
         DO 2101 J=1,K
         KD(J)=0
 2101    CONTINUE
      ENDIF
!
!     3.  CALCULATE SEVERAL PARAMETERS FOR LOOPING (FOR EFFICIENCY, THE
!         CODE OF SECTIONS 3.3 AND 3.4 FOR K=1 IS SEPARATED INTO 3.2)
!
!     3.1 NUMBER OF BITS USED PER WORD, INITIAL NR OF SKIPPED BITS
!
      ISTEP=KSIZE+KSKBTW
      ISKWS=KSKST
!
!     3.2 VECTOR LOOP LENGTH AND STEP SIZE IN KD IF K=1;KS STEP IRRELVNT
!
      IF(K.EQ.1)THEN
         ILL=1
         IBDL=2
         ISTD=1
      ELSE
!
!     3.3 STEP SIZES IN KS,KD: INVERSE OF LARGEST FACTOR OF ISTEP,KBPW
!
         ILCF=KBPW
         ISHF=ISTEP
 331     CONTINUE
         IF(ILCF.EQ.ISHF)GOTO 332
         IF(ILCF.EQ.1)GOTO 332
         IF(ILCF.GT.ISHF)THEN
            ILCF=ILCF-ISHF
         ELSE
            ISHF=ISHF-ILCF
         ENDIF
         GOTO 331
 332     CONTINUE
         ISTD=KBPW/ILCF
         ISTS=ISTEP/ILCF
!
!     3.4 VECTOR LOOP LENGTH AND SWITCH-OVER POINT FOR SMALLER LOOP
!
         ILL=(K-1)/ISTD+1
         IBDL=K-(ILL-1)*ISTD
      ENDIF
!
!     3.5 SWAP BYTES ON VAX WHEN DECODING
!
!
!     4.  LOOP OVER FIRST ISTD WORDS OF KD (TRAILS THE VECTOR LOOP)
!
      DO 790 JBD=1,ISTD
!
!     4.1 LAST BIT IN KS TO BE TREATED
!
      IENBS=ISKWS+KSIZE
!
!     4.2 NR OF WORDS OF KS TO BE SKIPPED, NR OF BITS IN THOSE AND THIS
!
      ISKW=ISKWS/KBPW
      ISTA=ISKW*KBPW
      ISKB=ISKWS-ISTA
!
!     4.3 MASK AND LEFT SHIFT FOR THE REMAINING BITS
!
      IMASK=KMASK(ISKB+1)
      ISH=KSIZE+ISKB
!
!     4.4 POSITION OF CURRENT WORD OF KS
!
      IBS=ISKW+1
!
!     5.  LOOP OVER WORDS OF KS CONTRIBUTING TO ONE WORD OF KD
!
 500  CONTINUE
!
!     5.1 UPDATE SHIFT AND LAST BIT IN CURRENT WORD
!
      ISH=ISH-KBPW
      IEND=ISTA+KBPW
!
!     5.2 IS LAST BIT OF CURRENT WORD OUTSIDE RANGE TO BE EXTRACTED
!
      IF(IEND.GT.IENBS)THEN
         ISH=IENBS-IEND
         IMASK=IAND(IMASK,NOT(KMASK(KBPW+ISH+1)))
      ENDIF
!
!     5.3 INITIAL OFFSETS FOR VECTOR ELEMENTS IN VECTOR LOOP
!
      IOS=0
      IOD=0
!
!     6.  VECTOR LOOP IS OVER REPEATEDLY OCCURRING BITPATTERNS/MASKS
!
      IF(YADIR.EQ.'D')THEN
!DIR$ IVDEP
         DO 611 JI=1,ILL
         KD(JBD+IOD)=IOR(KD(JBD+IOD),ISHFT(IAND(IMASK,KS(IBS+IOS)),ISH))
         IOD=IOD+ISTD
         IOS=IOS+ISTS
 611     CONTINUE
      ELSE
!DIR$ IVDEP
         DO 612 JI=1,ILL
         KS(IBS+IOS)=IOR(                                               &
     &   IAND(      KS(IBS+IOS),      NOT(IMASK)),                      &
     &   IAND(ISHFT(KD(JBD+IOD),-ISH),    IMASK ))
         IOD=IOD+ISTD
         IOS=IOS+ISTS
 612     CONTINUE
      ENDIF
!
!     7.  END LOOPS
!
!     7.1 PREPARE FOR END OF LOOP OVER WORDS OF KS WITIHN ONE KD WORD
!
      ISTA=ISTA+KBPW
!
!     7.2 NEXT WORD OF KD IF EXTRACTION NOT COMPLETED
!
      IF(ISTA.LT.IENBS)THEN
         IMASK=KMASK(1)
         IBS=IBS+1
         GOTO 500
      ENDIF
!
!     7.8 PREPARE FOR END OF LOOP OVER FIRST WORDS OF KD
!
      IF(JBD.EQ.IBDL)ILL=ILL-1
      ISKWS=ISKWS+ISTEP
!
!     7.9 END LOOP OVER FIRST WORDS OF KD
!
 790  CONTINUE
!
!     8.  FINISHED: UPDATE KSKST AND RETURN
!
      KSKST=KSKST+K*ISTEP
!
!     8.5 SWAP BYTES ON VAX
!
      IF (LHOOK) CALL DR_HOOK('GSBITE_MF',1,ZHOOK_HANDLE)
      ENDSUBROUTINE GSBITE_MF
