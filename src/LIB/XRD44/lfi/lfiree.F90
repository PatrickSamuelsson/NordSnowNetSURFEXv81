! Oct-2012 P. Marguinaud 64b LFI
! Jan-2011 P. Marguinaud Thread-safe LFI
SUBROUTINE LFIREE_FORT                                           &
&                     (LFI, KREP, KRANG, CDNOMA, KLONG, KRPIEX,  &
&                    KARTEX,                                     &
&                    KLONEX, KRPIEC, KARTEC, KPOSEC, KDTROU,     &
&                    KLONUT, KRETIN )
USE LFIMOD, ONLY : LFICOM
USE PARKIND1, ONLY : JPRB
USE YOMHOOK , ONLY : LHOOK, DR_HOOK
USE LFI_PRECISION
IMPLICIT NONE
!****
!        SOUS-PROGRAMME *INTERNE* DU LOGICIEL DE FICHIERS INDEXES LFI
!     RECHERCHE D'UN EMPLACEMENT OU ECRIRE UN ARTICLE LOGIQUE, DANS
!     L'UNITE LOGIQUE CONCERNEE.
!**
!    ARGUMENTS : KREP   (SORTIE) ==> CODE-REPONSE DU SOUS-PROGRAMME;
!                KRANG  (ENTREE) ==> RANG ( DANS LA TABLE *LFI%NUMERO* )
!                                    DE L'UNITE LOGIQUE CONCERNEE;
!                CDNOMA (ENTREE) ==> NOM DE L'ARTICLE A RECHERCHER;
!                KLONG  (ENTREE) ==> LONGUEUR DE L'ARTICLE A ECRIRE;
!                KRPIEX (SORTIE) ==> RANG ( DANS LE FICHIER ) DE L'ARTI-
!                                    CLE S'IL EXISTAIT DEJA ( 0 SINON );
!                KARTEX (SORTIE) ==> RANG ( DANS LA PAGE D'INDEX ) DE L'
!                                    ARTICLE S'IL EXISTAIT ( 0 SINON );
!                KLONEX (SORTIE) ==> LONGUEUR DE L'ARTICLE S'IL EXISTAIT
!                                    DEJA ( 0 SINON );
!                KRPIEC (SORTIE) ==> RANG ( DANS LE FICHIER ) DE L'ARTI-
!                                    CLE A ECRIRE;
!                KARTEC (SORTIE) ==> RANG ( DANS LA PAGE D'INDEX ) DE L'
!                                    ARTICLE A ECRIRE;
!                KPOSEC (SORTIE) ==> POSITION ( DANS LE FICHIER ) OU
!                                    COMMENCER A ECRIRE L'ARTICLE;
!                KDTROU (SORTIE) ==> VARIATION DU NOMBRE DE TROUS DANS
!                                    L'INDEX, DUE A CETTE ECRITURE;
!                KLONUT (SORTIE) ==> SI L'ON VA CREER UN TROU DANS L'IN-
!                                    DEX, LONGUEUR TOTALE UTILISABLE DE
!                                    CE TROU;
!                KRETIN (SORTIE) ==> CODE-RETOUR INTERNE.
!*
!    METHODE: SI L'ARTICLE EXISTE DEJA DANS LE FICHIER, ON ESSAIE AUTANT
!             QUE POSSIBLE DE "REECRIRE" SUR PLACE, CE QUI EST POSSIBLE
!             SI L'ON A UNE LONGUEUR D'ARTICLE INFERIEURE OU EGALE A
!             CELLE EXISTANTE, MAIS EST AUSSI POSSIBLE PAR RECYCLAGE
!             DE "TROUS" DE 2 CATEGORIES: EN FIN D'ARTICLE EXISTANT
!             ( AVANT L'ARTICLE LOGIQUE OU L'ARTICLE D'INDEX SUIVANT ),
!             ET/OU S'IL EXISTE UN "TROU" REPERTORIE DANS L'INDEX CORRE-
!             SPONDANT A UN ARTICLE LOGIQUE JUSTE DERRIERE CELUI EXIS-
!             TANT.
!                SI LA REECRITURE N'EST PAS POSSIBLE, ON ESSAIE ALORS DE
!             REUTILISER UN EVENTUEL "TROU" REPERTORIE DANS L'INDEX;
!             EN DESESPOIR DE CAUSE, ON ECRIT EN FIN DE FICHIER.
!
!
TYPE(LFICOM) :: LFI
CHARACTER CDNOMA*(*)
!
INTEGER (KIND=JPLIKB) KREP, KRANG, KLONG, KRPIEX, KARTEX 
INTEGER (KIND=JPLIKB) KLONEX, KRPIEC, KARTEC
INTEGER (KIND=JPLIKB) KPOSEC, KDTROU, KLONUT, ILCDNO, IRANG 
INTEGER (KIND=JPLIKB) ILTSUF, INTTRU, J
INTEGER (KIND=JPLIKB) INBALO, INBPIR, IFACTM, ILARPH
INTEGER (KIND=JPLIKB) INTPPI, IRNGSU, INALPP
INTEGER (KIND=JPLIKB) INPPIM, INPIME, INTROU, INPPI1 
INTEGER (KIND=JPLIKB) IDEBEX, IARTIC, IRGPIF
INTEGER (KIND=JPLIKB) INALPI, INPAGE, IRGPIM, IRPIFN 
INTEGER (KIND=JPLIKB) ILFORC, IPOSEX
INTEGER (KIND=JPLIKB) IPOSDX, IRECPI, ILSUIV, IPOSUI 
INTEGER (KIND=JPLIKB) IRGPI, IRPIMS, INPILE
INTEGER (KIND=JPLIKB) IRNGMS, INTRPI, ILTROU, IPTROU 
INTEGER (KIND=JPLIKB) IRPITR, IARTTR, IPOSTR
INTEGER (KIND=JPLIKB) IRPIMD, IRPIFD, INALDP, IRETOU 
INTEGER (KIND=JPLIKB) INIMES, INUMER, IRANGM
INTEGER (KIND=JPLIKB) IEXPLO (LFI%JPNPIA+LFI%JPNPIS+1) 
INTEGER (KIND=JPLIKB) INDICE (LFI%JPNAPX),  &
&        KRETIN, IRETIN
!
LOGICAL LLTSUF, LLTOPT, LLTTRU, LLRCHA
!
CHARACTER(LEN=LFI%JPLSPX) CLNSPR
CHARACTER(LEN=LFI%JPLMES) CLMESS
CHARACTER(LEN=LFI%JPLFTX) CLACTI
LOGICAL LLFATA

!**
!     1.  -  CONTROLES DES PARAMETRES D'APPEL ET INITIALISATIONS.
!-----------------------------------------------------------------------
!
REAL(KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK('LFIREE_FORT',0,ZHOOK_HANDLE)
CLACTI=''
ILCDNO=INT (LEN (CDNOMA), JPLIKB)
!
IF (KRANG.LE.0.OR.KRANG.GT.LFI%JPNXFI.OR.KLONG.LE.0.OR.        &
&    ILCDNO.LE.0.OR.ILCDNO.GT.LFI%JPNCPN.OR.CDNOMA.EQ.' ') THEN
  KREP=-16
  GOTO 1001
ENDIF
!
IRANG=KRANG
KREP=0
LLTSUF=.FALSE.
LLTOPT=.FALSE.
KARTEX=0
KARTEC=0
KRPIEC=0
KRPIEX=0
KLONEX=0
KLONUT=LFI%JPNIL
IRETOU=0
ILTSUF=0
INTTRU=LFI%MDES1D(IXM(LFI%JPNTRU,IRANG))+LFI%NBTROU(IRANG)
INBALO=LFI%MDES1D(IXM(LFI%JPNALO,IRANG))
INBPIR=LFI%MDES1D(IXM(LFI%JPNPIR,IRANG))
LLTTRU=INTTRU.EQ.0
IFACTM=LFI%MFACTM(IRANG)
ILARPH=LFI%JPLARD*IFACTM
INALPP=LFI%JPNAPP*IFACTM
INTPPI=(INBALO-1+INALPP)/INALPP
IF (LFI%LMISOP) WRITE (UNIT=LFI%NULOUT,FMT=*)                      &
&        'INBALO= ',INBALO,', INTTRU= ',INTTRU,', INTPPI= ',INTPPI, &
&        ', INBPIR= ',INBPIR
!
IF (INBALO.EQ.0) GOTO 240
!
IRNGSU=0
IRPIFN=1
INPPIM=LFI%NPPIMM(IRANG)
INPIME=0
INTROU=0
!
!**
!     2.  -  EXPLORATION DES (PAIRES DE) PAGES ET ARTICLES D'INDEX,
!            A LA RECHERCHE DE L'ARTICLE ET/OU D'UN "TROU" DANS L'INDEX,
!            SUFFISANT POUR Y "CASER" L'ARTICLE. ( ON COMMENCE
!            PAR EXPLORER LES PAGES D'INDEX )
!-----------------------------------------------------------------------
!
INPPI1=INPPIM
LLRCHA=.TRUE.
!
IF (LFI%NPODPI(IRANG).EQ.2) THEN
  IDEBEX=3
ELSE
  IDEBEX=2
ENDIF
!
IF (LLTTRU) THEN
!
  CALL LFIRAN_FORT                                              &
&                 (LFI, KREP,IRANG,CDNOMA,IRGPIM,IARTIC,IRETIN)
!
  IF (IRETIN.EQ.1) THEN
    GOTO 903
  ELSEIF (IRETIN.EQ.2) THEN
    GOTO 904
  ELSEIF (IRETIN.NE.0) THEN
    GOTO 1001
  ELSEIF (IARTIC.NE.0) THEN
!
!         ARTICLE TROUVE.
!
    IRGPIF=LFI%MRGPIF(IRGPIM)
    INALPI=MIN (INALPP,INBALO-(IRGPIF-1)*INALPP)
!
!         La ligne ci-dessous sert a eviter les ennuis entre les
!         etiquettes 213 et 215.
!
    INPAGE=INTPPI+1
    GOTO 212
  ELSE
!
!         IL VA FALLOIR CREER UN ARTICLE SUPPLEMENTAIRE.
!
    GOTO 240
  ENDIF
!
ENDIF
!
!     ... DEBUT D'UNE STRUCTURE DE TYPE "BOUCLE" SUR INPAGE,
!         QUI NE PEUT PAS (PLUS) ETRE UNE BOUCLE "DO" A PARTIR DU
!         MOMENT OU ON VEUT UTILISER, DES QUE POSSIBLE, "LFIRAN"
!         POUR UNE RECHERCHE D'ARTICLE MOINS COUTEUSE, SURTOUT LORSQUE
!         L'ARTICLE QUE L'ON CHERCHE ETAIT LE DERNIER TRAITE ...
!
INPAGE=1
!
201 CONTINUE
!
IF (INPAGE.LE.INPPI1) THEN
!
!           IL S'AGIT D'UNE EXPLORATION EN MEMOIRE ( PAGES D'INDEX ) .
!
  IRGPIM=LFI%MRGPIM(INPAGE,IRANG)
  IRGPIF=LFI%MRGPIF(IRGPIM)
  INPIME=INPIME+1
  IEXPLO(INPIME)=IRGPIF
  IF (IRGPIF.EQ.(IRPIFN+1)) IRPIFN=IRGPIF
ELSE
!
!           IL S'AGIT D'UNE EXPLORATION "HORS MEMOIRE";
!         ON CHERCHE LA PROCHAINE P.A.I. NON EXPLOREE .
!
  IF (INPAGE.EQ.INPPI1+1) THEN
!
    IF (IRNGSU.EQ.0) THEN
      IRGPIF=IRPIFN
    ELSE
!
!          Cas ou il y a eu, dans la recherche "en memoire",
!        recyclage d'une P.P.I. que l'on avait exploree precedemment.
!          Cette P.P.I. est restee sur place, n'a pas ete exploree,
!        et il serait bete de l'oublier, au risque de la dupliquer...
!
      IRGPIM=LFI%MRGPIM(IRNGSU,IRANG)
      IRGPIF=LFI%MRGPIF(IRGPIM)
      INPIME=INPIME+1
      IEXPLO(INPIME)=IRGPIF
      IF (IRGPIF.EQ.(IRPIFN+1)) IRPIFN=IRGPIF
      GOTO 210
    ENDIF
!
  ENDIF
!
202 CONTINUE
  IRGPIF=IRGPIF+1
!
  DO J=IDEBEX,INPIME
  IF (IEXPLO(J).EQ.IRGPIF) GOTO 202
  ENDDO
!
  ILFORC=1
  INPILE=1
  CALL LFIPIM_FORT                                               &
&                 (LFI, KREP,IRANG,IRANGM,IRGPIM,IRGPIF,ILFORC,  &
&                  INPILE, IRETIN)
!
  IF (IRETIN.EQ.1) THEN
    GOTO 903
  ELSEIF (IRETIN.EQ.2) THEN
    GOTO 904
  ELSEIF (IRETIN.NE.0) THEN
    GOTO 1001
  ENDIF
!
  INPPIM=MAX (INPPIM,IRANGM)
ENDIF
!*
!     2.1 -  "BOUCLE" DE RECHERCHE SUR LES ARTICLES PRESENTS DANS
!             LA (PAIRE DE) PAGE D'INDEX DE RANG IRGPIF DANS LE FICHIER.
!-----------------------------------------------------------------------
!
210 CONTINUE
INALPI=MIN (INALPP,INBALO-(IRGPIF-1)*INALPP)
IARTIC=0
!
IF (LLRCHA) THEN
!
  DO J=1,INALPI
!
  IF (LFI%CNOMAR(IXC(J,IRGPIM)).EQ.CDNOMA) THEN
    IARTIC=J
    GOTO 212
  ENDIF
!
  ENDDO
!
ENDIF
!
212 CONTINUE
!
IF (IARTIC.NE.0) THEN
!
!        ON A TROUVE DANS LE FICHIER UN ARTICLE DE MEME NOM QUE CELUI A
!        ECRIRE.
!
  LLRCHA=.FALSE.
!
  IF (.NOT.LFI%LPHASP(IRGPIM)) THEN
!
    CALL LFIPHA_FORT                                &
&                   (LFI, KREP,IRANG,IRGPIM,IRETIN)
!
    IF (IRETIN.EQ.1) THEN
      GOTO 903
    ELSEIF (IRETIN.EQ.2) THEN
      GOTO 904
    ELSEIF (IRETIN.NE.0) THEN
      GOTO 1001
    ENDIF
!
  ENDIF
!
  KRPIEX=IRGPIF
  KLONEX=LFI%MLGPOS(IXM(2*IARTIC-1,IRGPIM))
  IPOSEX=LFI%MLGPOS(IXM(2*IARTIC,IRGPIM))
  KARTEX=IARTIC
!
  IF (KLONG.LE.KLONEX) THEN
!
!       L'ARTICLE TROUVE EST AU MOINS AUSSI LONG QUE CELUI QUE L'ON VEUT
!       ECRIRE: UNE ECRITURE AU MEME EMPLACEMENT EST DONC POSSIBLE.
!
    KRPIEC=IRGPIF
    KARTEC=IARTIC
    KPOSEC=IPOSEX
    GOTO 240
  ELSE
!
!     CAS DE REECRITURE + LONGUE QUE L'ARTICLE EXISTANT SUR LE FICHIER.
!
    IPOSDX=LFI%MLGPOS(IXM(2*IARTIC,IRGPIM))+KLONG-1
!
    IF (IARTIC.EQ.1.AND.IRGPIF.GT.INBPIR) THEN
!
!            IL Y A EU DEBORDEMENT DES P.A.I. PREALLOUEES, ET IL Y A
!        EN OUTRE UNE P.A.I. SUR LE FICHIER, JUSTE DERRIERE L'ARTICLE
!        LOGIQUE AUQUEL ON S'INTERESSE. ON REGARDE S'IL Y A ASSEZ DE
!        PLACE AVANT LA P.A.I. POUR UNE REECRITURE AU MEME ENDROIT.
!        ( P.A.I. = PAIRE D'ARTICLES D'INDEX )
!
      IRECPI=LFI%MDES1D(IXM(ILARPH+1-(IRGPIF-INBPIR),IRANG))
      KLONUT=ILARPH*(IRECPI-1)-IPOSEX+1
!
      IF (KLONG.LE.KLONUT) THEN
        KRPIEC=IRGPIF
        KARTEC=IARTIC
        KPOSEC=IPOSEX
        GOTO 240
      ELSE
        GOTO 216
      ENDIF
!
    ELSEIF (IARTIC.EQ.INALPI.AND.IRGPIF.EQ.INTPPI) THEN
!
!           CAS OU L'ARTICLE TROUVE EST LE DERNIER ARTICLE LOGIQUE DE
!        DONNEES, SANS P.A.I. JUSTE DERRIERE. IL Y A DE LA PLACE DONC...
!
      KRPIEC=IRGPIF
      KARTEC=IARTIC
      KPOSEC=IPOSEX
      GOTO 240
    ENDIF
!
  ENDIF
!
!            EN ARRIVANT ICI, ON EST DONC SUR QUE L'ARTICLE TROUVE
!          N'EST PAS LE DERNIER ARTICLE LOGIQUE.
!
!     ON VA REGARDER SI, PAR CHANCE, L'ARTICLE LOGIQUE SUIVANT N'EST
!     PAS UN TROU SUFFISANT POUR "CASER" L'EXCEDENT DE DONNEES,
!     OU S'IL N'Y A PAS UN TROU DE DONNEES ( NON ASSOCIE A UN TROU DANS
!     LA PARTIE "NOMS" DE L'INDEX ) SUFFISANT EN FIN D'ARTICLE EXISTANT,
!     AVANT L'ARTICLE LOGIQUE SUIVANT...
!
  IF (IARTIC.NE.INALPI) THEN
!
!             L'ARTICLE SUIVANT EST DANS LA MEME PAGE D'INDEX...
!
    ILSUIV=LFI%MLGPOS(IXM(2*IARTIC+1,IRGPIM))
    IPOSUI=LFI%MLGPOS(IXM(2*IARTIC+2,IRGPIM))
    KLONUT=IPOSUI-IPOSEX
!
    IF (KLONG.LE.KLONUT) THEN
!
!     ... ET IL Y A UN "TROU" SUFFISANT AVANT CET ARTICLE POUR POUVOIR
!         ECRIRE LES DONNEES EXCEDENTAIRES.
!
      KRPIEC=IRGPIF
      KARTEC=IARTIC
      KPOSEC=IPOSEX
      GOTO 240
!
    ELSEIF (LFI%CNOMAR(IXC(IARTIC+1,IRGPIM)).EQ.' ' &
&            .AND.KLONG.LE.(KLONUT+ILSUIV)) THEN
!
!     ... ET C'EST UN TROU QUI PERMET, AVEC L'AIDE EVENTUELLE
!         D'UNE ZONE DE DONNEES "MORTE" ENTRE LES 2 ARTICLES,
!         DE MENAGER UNE PLACE SUFFISANTE POUR L'EXCES DE DONNEES.
!
      LFI%MLGPOS(IXM(2*IARTIC+1,IRGPIM))=IPOSUI+ILSUIV-(IPOSDX+1)
      LFI%MLGPOS(IXM(2*IARTIC+2,IRGPIM))=IPOSDX+1
      LFI%LECRPI(IRGPIM,2)=.TRUE.
      KRPIEC=IRGPIF
      KARTEC=IARTIC
      KPOSEC=IPOSEX
!
      IF (LFI%MLGPOS(IXM(2*IARTIC+1,IRGPIM)).EQ.0) THEN
        GOTO 230
      ELSE
        GOTO 240
      ENDIF
!
    ENDIF
!
!     ... L'ARTICLE SUIVANT N'EST PAS EXPLOITABLE POUR ECRIRE L'EXCES
!         DE DONNEES.
!
    GOTO 216
  ELSE
!
!     L'ARTICLE TROUVE EST CERTES TROP COURT, MAIS IL EST EN PLUS EN FIN
!     DE PAGE D'INDEX...
!
    DO J=2,INPPIM
    IRGPI=LFI%MRGPIM(J,IRANG)
!
    IF (LFI%MRGPIF(IRGPI).EQ.(IRGPIF+1)) THEN
!
      IRPIMS=IRGPI
!
      IF (.NOT.LFI%LPHASP(IRPIMS)) THEN
!
        CALL LFIPHA_FORT                                &
&                       (LFI, KREP,IRANG,IRPIMS,IRETIN)
!
        IF (IRETIN.EQ.1) THEN
          GOTO 903
        ELSEIF (IRETIN.EQ.2) THEN
          GOTO 904
        ELSEIF (IRETIN.NE.0) THEN
          GOTO 1001
        ENDIF
!
      ENDIF
!
      GOTO 215
!
    ENDIF
!
    ENDDO
!
!             LA P.A.I. SUIVANTE (EN RANG DANS LE FICHIER) N'EST PAS
!          EN MEMOIRE; DECIDEMENT, CELA SE GATE ! ... ON L'Y MET.
!
!             Noter que ce cas de figure ne peut se presenter q'une
!          seule fois par exploration de l'index.
!
    INPILE=2
    CALL LFIPIM_FORT                                                &
&                   (LFI, KREP,IRANG,IRNGMS,IRPIMS,IRGPIF+1,IRGPIF, &
&                    INPILE, IRETIN)
!
    IF (IRETIN.EQ.1) THEN
      GOTO 903
    ELSEIF (IRETIN.EQ.2) THEN
      GOTO 904
    ELSEIF (IRETIN.NE.0) THEN
      GOTO 1001
    ENDIF
!
    IF (INPAGE.LE.INPPIM) THEN
!
!               On est dans le cadre d'une exploration "en memoire"...
!
      IF (IRNGMS.GT.INPPIM) THEN
!
!               ... et il y aura une P.P.I. a explorer en plus,
!                   a la fin du balayage "en memoire".
!
        INPPI1=INPPI1+1
      ELSEIF (IRNGMS.LT.INPAGE) THEN
!
!               ... et il y aura une P.P.I. a explorer en plus,
!                   mais apres le balayage "en memoire".
!
        IRNGSU=IRNGMS
      ENDIF
!
    ENDIF
!
    INPPIM=MAX (INPPIM,IRNGMS)
!
215 CONTINUE
!
!            LA PAIRE D'ARTICLES D'INDEX SUIVANTE EST EN MEMOIRE.
!
    ILSUIV=LFI%MLGPOS(IXM(1_JPLIKB ,IRPIMS))
    IPOSUI=LFI%MLGPOS(IXM(2_JPLIKB ,IRPIMS))
    KLONUT=IPOSUI-IPOSEX
!
    IF (KLONG.LE.KLONUT) THEN
!
!     ... ET IL Y A UN "TROU" SUFFISANT AVANT CETTE PAIRE POUR POUVOIR
!         ECRIRE LES DONNEES EXCEDENTAIRES.
!
      KRPIEC=IRGPIF
      KARTEC=IARTIC
      KPOSEC=IPOSEX
      GOTO 240
!
    ELSEIF (LFI%CNOMAR(IXC(1_JPLIKB ,IRPIMS)).EQ.' ' &
&           .AND.KLONG.LE.(KLONUT+ILSUIV)) THEN
!
!     ... ET C'EST UN TROU QUI PERMET, AVEC L'AIDE EVENTUELLE
!         D'UNE ZONE DE DONNEES "MORTE" ENTRE LES 2 ARTICLES,
!         DE MENAGER UNE PLACE SUFFISANTE POUR L'EXCES DE DONNEES.
!
      LFI%MLGPOS(IXM(1_JPLIKB ,IRPIMS))= &
&              IPOSUI+ILSUIV-(IPOSDX+1)
      LFI%MLGPOS(IXM(2_JPLIKB ,IRPIMS))=IPOSDX+1
      LFI%LECRPI(IRPIMS,2)=.TRUE.
      KRPIEC=IRGPIF
      KARTEC=IARTIC
      KPOSEC=IPOSEX
!
      IF (LFI%MLGPOS(IXM(1_JPLIKB ,IRPIMS)).EQ.0) THEN
        GOTO 230
      ELSE
        GOTO 240
      ENDIF
!
    ENDIF
!
!              SI ON ARRIVE ICI, IL FAUT PASSER A LA PAGE SUIVANTE .
!
  ENDIF
!
ENDIF
!
216 CONTINUE
!
!        RECHERCHE EVENTUELLE DE TROUS D'INDEX DE LONGUEUR ADEQUATE.
!
IF (LLTTRU.OR.LLTOPT) THEN
!
  IF (.NOT.LLRCHA) THEN
    GOTO 240
  ELSE
    GOTO 229
  ENDIF
!
ELSE
  INTRPI=0
!
  DO J=1,INALPI
!
  IF (LFI%CNOMAR(IXC(J,IRGPIM)).EQ.' ') THEN
    INTRPI=INTRPI+1
    INDICE(INTRPI)=J
  ENDIF
!
  ENDDO
!
ENDIF
!
IF (INTRPI.NE.0) THEN
!
  IF (.NOT.LFI%LPHASP(IRGPIM)) THEN
!
    CALL LFIPHA_FORT                                &
&                   (LFI, KREP,IRANG,IRGPIM,IRETIN)
!
    IF (IRETIN.EQ.1) THEN
      GOTO 903
    ELSEIF (IRETIN.EQ.2) THEN
      GOTO 904
    ELSEIF (IRETIN.NE.0) THEN
      GOTO 1001
    ENDIF
!
  ENDIF
!
  DO J=1,INTRPI
  IARTIC=INDICE(J)
  ILTROU=LFI%MLGPOS(IXM(2*IARTIC-1,IRGPIM))
  IPTROU=LFI%MLGPOS(IXM(2*IARTIC,IRGPIM))
!
  IF (ILTROU.GE.KLONG) THEN
!
!             "TROU" D'INDEX DE LONGUEUR SUFFISANTE POUR L'ARTICLE.
!
    IF (.NOT.LLTSUF) THEN
      LLTSUF=.TRUE.
      ILTSUF=ILTROU+1
    ENDIF
!
    IF (ILTROU.LT.ILTSUF) THEN
      ILTSUF=ILTROU
      IRPITR=IRGPIF
      IARTTR=IARTIC
      IPOSTR=IPTROU
    ENDIF
!
    LLTOPT=ILTSUF.EQ.KLONG
  ENDIF
!
  ENDDO
!
  INTROU=INTROU+INTRPI
  LLTTRU=INTROU.EQ.INTTRU
ENDIF
!
!      SI L'ARTICLE A ETE TROUVE PRECEDEMMENT DANS LE FICHIER MAIS TROP
!     COURT, ET SI ON A EXPLORE TOUS LES TROUS REFERENCES DANS L'INDEX,
!     ON ARRETE L'EXPLORATION DE L'INDEX.
!
IF (LLTTRU.AND.KARTEX.NE.0) GOTO 240
!
!     .... FIN DE "BOUCLE", ON REMONTE POUR UNE EVENTUELLE SUITE ...
!
229 CONTINUE
INPAGE=INPAGE+1
!
IF (INPAGE.LE.INTPPI) THEN
  GOTO 201
ELSE
  GOTO 240
ENDIF
!
230 CONTINUE
!*
!     2.3 - CAS OU L'ON A CREE UN TROU DE LONGUEUR NULLE DANS L'INDEX
!           ON STOCKE DE QUOI S'EN OCCUPER PLUS TARD, A LA FERMETURE.
!-----------------------------------------------------------------------
!
IF (LFI%NTRULZ(IRANG).EQ.0) THEN
  LFI%NRFPTZ(IRANG)=IPOSEX
  LFI%NRFDTZ(IRANG)=IPOSEX
ELSE
  LFI%NRFPTZ(IRANG)=MIN (LFI%NRFPTZ(IRANG),IPOSEX)
  LFI%NRFDTZ(IRANG)=MAX (LFI%NRFDTZ(IRANG),IPOSEX)
ENDIF
!
LFI%NTRULZ(IRANG)=LFI%NTRULZ(IRANG)+1
!
240 CONTINUE
IF (LFI%LMISOP)                                               &
&  WRITE (UNIT=LFI%NULOUT,FMT=*)'LFIREE - APRES ETIQUETTE 240'
!*
!     2.4 - CALCUL DE LA VARIATION DU NOMBRE DE TROUS REFERENCES
!           DANS L'INDEX.
!-----------------------------------------------------------------------
!
IF (KARTEX.NE.0.AND.KARTEC.EQ.0.AND..NOT.LLTSUF) THEN
  KDTROU=1
ELSEIF (KARTEX.EQ.0.AND.LLTSUF) THEN
  KDTROU=-1
ELSE
  KDTROU=0
ENDIF
!*
!     2.5  -   QUAND AUCUN EMPLACEMENT CONVENABLE N'A ETE TROUVE,
!              IL RESTE A DEFINIR LE RANG DE L'ARTICLE DANS LE FICHIER,
!              AINSI QUE LA POSITION DU PREMIER MOT DE DONNEES A ECRIRE.
!-----------------------------------------------------------------------
!
IF (KARTEC.EQ.0) THEN
!
  IF (LLTSUF) THEN
    KRPIEC=IRPITR
    KARTEC=IARTTR
    KPOSEC=IPOSTR
  ELSE
    KRPIEC=1+INBALO/INALPP
    KARTEC=INBALO+1-INALPP*(KRPIEC-1)
!
    IF (LFI%NALDPI(IRANG).EQ.INALPP                     &
&        .AND.INTPPI.EQ.(INBPIR+ILARPH-LFI%JPLDOC)) THEN
      KREP=-17
      GOTO 1001
    ENDIF
!
!     DEFINITION DE LA POSITION OU ECRIRE, DANS LE CAS D'UN ARTICLE
!     LOGIQUE SUPPLEMENTAIRE.
!
    IF (INBALO.EQ.0) THEN
      KPOSEC=(1+2*INBPIR)*ILARPH+1
    ELSE
      IRPIMD=LFI%MRGPIM(LFI%NPODPI(IRANG),IRANG)
      INALDP=LFI%NALDPI(IRANG)
      KPOSEC=LFI%MLGPOS(IXM(2*INALDP,IRPIMD))    &
&             +LFI%MLGPOS(IXM(2*INALDP-1,IRPIMD))
!
      IF (INTPPI.GT.INBPIR) THEN
        IRPIFD=LFI%MDES1D(IXM(ILARPH+1-(INTPPI-INBPIR),IRANG))+1
        KPOSEC=MAX (KPOSEC,1+ILARPH*IRPIFD)
      ENDIF
!
    ENDIF
!
  ENDIF
!
ENDIF
!
GOTO 1001
!**
!     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
!      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
!-----------------------------------------------------------------------
!
903 CONTINUE
IRETOU=1
CLACTI='WRITE'
GOTO 909
!
904 CONTINUE
IRETOU=2
CLACTI='READ'
!
909 CONTINUE
KREP=ABS (KREP)
!**
!    10.  -  PHASE TERMINALE : MESSAGERIE INTERNE EVENTUELLE,
!            VIA LE SOUS-PROGRAMME "LFIEMS", PUIS RETOUR.
!-----------------------------------------------------------------------
!
1001 CONTINUE
LLFATA=LLMOER (KREP,KRANG)
!
IF (KREP.EQ.0) THEN
  KRETIN=0
ELSEIF (KREP.GT.0) THEN
  KRETIN=IRETOU
ELSE
  KRETIN=3
ENDIF
!
IF (LFI%LMISOP.OR.LLFATA) THEN
  INIMES=2
  CLNSPR='LFIREE'
  WRITE (UNIT=CLMESS,                                              &
&         FMT='(''ARGUMENTS='',I4,'','',I3,'','''''',               &
&         A,'''''','',I7,'','',I4,'','',I4,'','',I7,'','',I4,'','', &
&         I4,'','',I9,'','',SP,I2,SS,'','',I7,'','',I2)')           &
&  KREP,KRANG,CDNOMA,KLONG,KRPIEX,KARTEX,KLONEX,                    &
&  KRPIEC,KARTEC,KPOSEC,KDTROU,KLONUT,KRETIN
  INUMER=LFI%NUMERO(KRANG)
  CALL LFIEMS_FORT                                  &
&                 (LFI, INUMER,INIMES,KREP,.FALSE., &
&                  CLMESS,CLNSPR,CLACTI)
ENDIF
!
IF (LHOOK) CALL DR_HOOK('LFIREE_FORT',1,ZHOOK_HANDLE)

CONTAINS

#include "lficom2.ixc.h"
#include "lficom2.ixm.h"
#include "lficom2.llmoer.h"

END SUBROUTINE LFIREE_FORT



! Oct-2012 P. Marguinaud 64b LFI
SUBROUTINE LFIREE64                                            &
&           (KREP, KRANG, CDNOMA, KLONG, KRPIEX, KARTEX, KLONEX, &
&           KRPIEC, KARTEC, KPOSEC, KDTROU, KLONUT, KRETIN)
USE LFIMOD, ONLY : LFI => LFICOM_DEFAULT, &
&                   LFICOM_DEFAULT_INIT,   &
&                   NEW_LFI_DEFAULT
USE LFI_PRECISION
IMPLICIT NONE
! Arguments
INTEGER (KIND=JPLIKB)  KREP                                   !   OUT
INTEGER (KIND=JPLIKB)  KRANG                                  ! IN   
CHARACTER (LEN=*)      CDNOMA                                 ! IN   
INTEGER (KIND=JPLIKB)  KLONG                                  ! IN   
INTEGER (KIND=JPLIKB)  KRPIEX                                 !   OUT
INTEGER (KIND=JPLIKB)  KARTEX                                 !   OUT
INTEGER (KIND=JPLIKB)  KLONEX                                 !   OUT
INTEGER (KIND=JPLIKB)  KRPIEC                                 !   OUT
INTEGER (KIND=JPLIKB)  KARTEC                                 !   OUT
INTEGER (KIND=JPLIKB)  KPOSEC                                 !   OUT
INTEGER (KIND=JPLIKB)  KDTROU                                 !   OUT
INTEGER (KIND=JPLIKB)  KLONUT                                 !   OUT
INTEGER (KIND=JPLIKB)  KRETIN                                 !   OUT

IF (.NOT. LFICOM_DEFAULT_INIT) CALL NEW_LFI_DEFAULT ()

CALL LFIREE_FORT                                            &
&           (LFI, KREP, KRANG, CDNOMA, KLONG, KRPIEX, KARTEX, &
&           KLONEX, KRPIEC, KARTEC, KPOSEC, KDTROU, KLONUT,   &
&           KRETIN)

END SUBROUTINE LFIREE64

SUBROUTINE LFIREE                                              &
&           (KREP, KRANG, CDNOMA, KLONG, KRPIEX, KARTEX, KLONEX, &
&           KRPIEC, KARTEC, KPOSEC, KDTROU, KLONUT, KRETIN)
USE LFIMOD, ONLY : LFI => LFICOM_DEFAULT, &
&                   LFICOM_DEFAULT_INIT,   &
&                   NEW_LFI_DEFAULT
USE LFI_PRECISION
IMPLICIT NONE
! Arguments
INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
INTEGER (KIND=JPLIKM)  KRANG                                  ! IN   
CHARACTER (LEN=*)      CDNOMA                                 ! IN   
INTEGER (KIND=JPLIKM)  KLONG                                  ! IN   
INTEGER (KIND=JPLIKM)  KRPIEX                                 !   OUT
INTEGER (KIND=JPLIKM)  KARTEX                                 !   OUT
INTEGER (KIND=JPLIKM)  KLONEX                                 !   OUT
INTEGER (KIND=JPLIKM)  KRPIEC                                 !   OUT
INTEGER (KIND=JPLIKM)  KARTEC                                 !   OUT
INTEGER (KIND=JPLIKM)  KPOSEC                                 !   OUT
INTEGER (KIND=JPLIKM)  KDTROU                                 !   OUT
INTEGER (KIND=JPLIKM)  KLONUT                                 !   OUT
INTEGER (KIND=JPLIKM)  KRETIN                                 !   OUT

IF (.NOT. LFICOM_DEFAULT_INIT) CALL NEW_LFI_DEFAULT ()

CALL LFIREE_MT                                              &
&           (LFI, KREP, KRANG, CDNOMA, KLONG, KRPIEX, KARTEX, &
&           KLONEX, KRPIEC, KARTEC, KPOSEC, KDTROU, KLONUT,   &
&           KRETIN)

END SUBROUTINE LFIREE

SUBROUTINE LFIREE_MT                                        &
&           (LFI, KREP, KRANG, CDNOMA, KLONG, KRPIEX, KARTEX, &
&           KLONEX, KRPIEC, KARTEC, KPOSEC, KDTROU, KLONUT,   &
&           KRETIN)
USE LFIMOD, ONLY : LFICOM
USE LFI_PRECISION
IMPLICIT NONE
! Arguments
TYPE (LFICOM)          LFI                                    ! INOUT
INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
INTEGER (KIND=JPLIKM)  KRANG                                  ! IN   
CHARACTER (LEN=*)      CDNOMA                                 ! IN   
INTEGER (KIND=JPLIKM)  KLONG                                  ! IN   
INTEGER (KIND=JPLIKM)  KRPIEX                                 !   OUT
INTEGER (KIND=JPLIKM)  KARTEX                                 !   OUT
INTEGER (KIND=JPLIKM)  KLONEX                                 !   OUT
INTEGER (KIND=JPLIKM)  KRPIEC                                 !   OUT
INTEGER (KIND=JPLIKM)  KARTEC                                 !   OUT
INTEGER (KIND=JPLIKM)  KPOSEC                                 !   OUT
INTEGER (KIND=JPLIKM)  KDTROU                                 !   OUT
INTEGER (KIND=JPLIKM)  KLONUT                                 !   OUT
INTEGER (KIND=JPLIKM)  KRETIN                                 !   OUT
! Local integers
INTEGER (KIND=JPLIKB)  IREP                                   !   OUT
INTEGER (KIND=JPLIKB)  IRANG                                  ! IN   
INTEGER (KIND=JPLIKB)  ILONG                                  ! IN   
INTEGER (KIND=JPLIKB)  IRPIEX                                 !   OUT
INTEGER (KIND=JPLIKB)  IARTEX                                 !   OUT
INTEGER (KIND=JPLIKB)  ILONEX                                 !   OUT
INTEGER (KIND=JPLIKB)  IRPIEC                                 !   OUT
INTEGER (KIND=JPLIKB)  IARTEC                                 !   OUT
INTEGER (KIND=JPLIKB)  IPOSEC                                 !   OUT
INTEGER (KIND=JPLIKB)  IDTROU                                 !   OUT
INTEGER (KIND=JPLIKB)  ILONUT                                 !   OUT
INTEGER (KIND=JPLIKB)  IRETIN                                 !   OUT
! Convert arguments

IRANG      = INT (     KRANG, JPLIKB)
ILONG      = INT (     KLONG, JPLIKB)

CALL LFIREE_FORT                                            &
&           (LFI, IREP, IRANG, CDNOMA, ILONG, IRPIEX, IARTEX, &
&           ILONEX, IRPIEC, IARTEC, IPOSEC, IDTROU, ILONUT,   &
&           IRETIN)

KREP       = INT (      IREP, JPLIKM)
KRPIEX     = INT (    IRPIEX, JPLIKM)
KARTEX     = INT (    IARTEX, JPLIKM)
KLONEX     = INT (    ILONEX, JPLIKM)
KRPIEC     = INT (    IRPIEC, JPLIKM)
KARTEC     = INT (    IARTEC, JPLIKM)
KPOSEC     = INT (    IPOSEC, JPLIKM)
KDTROU     = INT (    IDTROU, JPLIKM)
KLONUT     = INT (    ILONUT, JPLIKM)
KRETIN     = INT (    IRETIN, JPLIKM)

END SUBROUTINE LFIREE_MT

!INTF KREP            OUT 
!INTF KRANG         IN    
!INTF CDNOMA        IN    
!INTF KLONG         IN    
!INTF KRPIEX          OUT 
!INTF KARTEX          OUT 
!INTF KLONEX          OUT 
!INTF KRPIEC          OUT 
!INTF KARTEC          OUT 
!INTF KPOSEC          OUT 
!INTF KDTROU          OUT 
!INTF KLONUT          OUT 
!INTF KRETIN          OUT 
