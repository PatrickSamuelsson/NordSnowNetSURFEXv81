      SUBROUTINE GBYTES_MF(KS,KD,KSKIP1,KBSIZ,KSKIP2,KBYTES)
      USE PARKIND1, ONLY : JPRB
      USE YOMHOOK , ONLY : LHOOK, DR_HOOK
      USE LFI_PRECISION
!
! KS CONTAINS A BIT STRING OF INDEFINITE LENGTH. GBYTES WILL
! EXTRACT KBYTES BITSTRINGS, KBSIZ BITS LONG, AND STORE THEM
! RIGHT JUSTIFIED 0 FILL, INTO SUCCESSIVE WORDS OF KD. THE
! SUCCESSIVE BITSTRINGS START AT BIT POSITIONS
!     KSKIP1+1+(IBYTE-1)*(KBSIZ+KSKIP2)
! IN THE BIT STRING S. I.E. SKIP KSKIP1 BITS AT THE START,
! AND KSKIP2 BITS BETWEEN THE EXTRACTED STRINGS.
! BIT ISKP+1 IN A STRING IS FOUND IN WORD IS=1+ISKIP/INBPW IN KS,
! WHERE INBPW IS THE NUMBER OF BITS PER WORD. THE STARTING BIT
! IS FOUND BY SKIPPING MOD(ISKP,INBPW) BITS IN THAT WORD.
! KWOFF IS AN OPTIONAL 7TH PARAMETER, WHICH DEFAULTS TO 0
! IF PRESENT KWOFF BITS ARE TOTALLY IGNORED AT THE START OF A WORD
! THUS IF A PACKED CYBER BIT STRING IS TRANSFERRED TO THE
! CRAY, WITH EACH 60 BIT CYBER WORD PLACED AT THE RIGHT END OF
! A 64 BIT CRAY WORD, A BYTE SEQUENCE WHICH WAS ORIGINALLY
! LOCATED WITH START POINTS IN ARITHMETIC PROGRESSION ON THE
! CYBER, WILL NO LONGER HAVE THIS PROPERTY ON THE CRAY. BY
! USING THE ROUTINE WITH KWOFF=4, THE ELEMENTS OF THE BYTE
! SEQUENCE CAN BE EXTRACTED ON THE CRAY, USING THE SAME SKIPS
! AS WERE USED ON THE CYBER.
!
!*    Author: ?????, ECMWF, 198x.
!*
!*    Modified by Mats HAMRUD, ECMWF, 1988, to have a constant number
!*    number af arguments , as within the GRIB package calls,
!*    and to make some cleanings.
!*
!*    Modifications by Jean CLOCHARD, French DMN, January 1990,
!*    essentially to get a vectorising code on CRAY (no recurrences),
!*    and to make some cleanings.
!
      IMPLICIT NONE
!
      INTEGER (KIND=JPLIKM) :: KSKIP1
      INTEGER (KIND=JPLIKM) :: KBSIZ
      INTEGER (KIND=JPLIKM) :: KSKIP2
      INTEGER (KIND=JPLIKM) :: KBYTES
!
      INTEGER (KIND=JPLIKB) :: KS(*)
      INTEGER (KIND=JPLIKB) :: KD(KBYTES)
!
      INTEGER (KIND=JPLIKM) :: INBPW, ISTEP, JBYTE, ID
      INTEGER (KIND=JPLIKM) :: ISKIP, ISH1, ISH2, IS, IAUXIL
!
      REAL(KIND=JPRB) :: ZHOOK_HANDLE
      IF (LHOOK) CALL DR_HOOK('GBYTES_MF',0,ZHOOK_HANDLE)
      INBPW=64
      ISTEP = KSKIP2+KBSIZ
!
      DO 75 JBYTE = 1 , KBYTES
!
! WITH THE STARTING WORD AND BIT POSITION DETERMINED, THE
! DESIRED EXTRACTION CAN BE DONE BY
!***     CALL GBYTE(KS(IS),KD(JBYTE),ISKIP,KBSIZ)
! BUT SINCE THE CODE IS SHORT IT IS INSERTED IN-LINE.
!
      IAUXIL=KSKIP1+(JBYTE-1)*ISTEP
      IS=1+IAUXIL/INBPW
      ISKIP=IAUXIL-(IS-1)*INBPW
      ISH1=ISKIP+KBSIZ
!
      IF(ISH1.LE.INBPW) THEN
!*
! BYTE COMES FROM 1 WORD OF KS
!
         KD(JBYTE) = IBITS (KS(IS),INBPW-ISH1,KBSIZ)
      ELSE
         ISH2 =ISH1-INBPW
!*
! BYTE COMES FROM 2 WORDS OF KS.
!
         KD(JBYTE) = IOR ( ISHFT ( IBITS (KS(IS),0,INBPW-ISKIP), ISH2 ) &
     &                    ,                                             &
     &                     IBITS (KS(IS+1),INBPW-ISH2,ISH2)             &
     &                   )
      ENDIF
!
   75 CONTINUE
!
      IF (LHOOK) CALL DR_HOOK('GBYTES_MF',1,ZHOOK_HANDLE)
      ENDSUBROUTINE GBYTES_MF
